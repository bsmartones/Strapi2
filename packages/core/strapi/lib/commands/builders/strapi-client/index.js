'use strict';

const { getConfigUrls } = require('@strapi/utils');
const tsUtils = require('@strapi/typescript-utils');

const chalk = require('chalk');
const path = require('path');
const fs = require('fs-extra');
const viteReact = require('@vitejs/plugin-react');
const { nodeResolve } = require('@rollup/plugin-node-resolve');
const ee = require('../../../utils/ee');
const addSlash = require('../../../utils/addSlash');
const strapiNodeApp = require('../../../Strapi');
const getEnabledPlugins = require('../../../core/loaders/plugins/get-enabled-plugins');
const { loadPkg } = require('../../utils/pkg');
const { viteBuildTask } = require('../vite/viteBuildTask');
const { decorateHTMLWithAutoGeneratedWarning, getDocumentHTML } = require('./document');
const { getEntryModule } = require('./entry');

/**
 * @typedef AdminBuilderArgs
 * @property {"vite" | "webpack"} builder
 * @property {string} distDir
 * @property {string} cwd
 * @property {string | undefined} tsconfig
 */

/**
 * @type {({ builder, distDir, cwd, tsconfig }: AdminBuilderArgs) => Promise<void>}
 */
const buildAdmin = async ({ distDir, cwd, builder, tsconfig }) => {
  const spinner = createSpinner(`Building your admin UI with production configuration...`);

  const strapiInstance = strapiNodeApp({
    // Directories
    appDir: cwd,
    distDir,
    // Options
    autoReload: true,
    serveAdminPanel: false,
  });

  const ctx = await createBuildContext({ cwd, tsconfig, distDir });

  try {
    const plugins = await getEnabledPlugins(strapiInstance);

    const { serverUrl, adminPath } = getConfigUrls(strapiInstance.config, true);

    ee.init(cwd);

    console.log(builder);

    if (builder === 'vite') {
      /**
       * For Vite to work effectively we create a client fold er in `.strapi` at the cwd level.
       * We then use the function we need to "createAdmin" as well as generate the Document index.html as well.
       *
       * All this links together an imaginary "src/index" that then allows vite to correctly build the admin panel.
       */

      const runtimeDir = path.join(cwd, '.strapi', 'client');

      await fs.mkdir(runtimeDir, { recursive: true });

      const indexHtml = decorateHTMLWithAutoGeneratedWarning(
        getDocumentHTML({
          props: {
            isVite: true,
            entryPath: `/${path.relative(cwd, path.join(runtimeDir, 'app.js'))}`,
          },
        })
      );

      await fs.writeFile(path.join(runtimeDir, 'index.html'), indexHtml);
      await fs.writeFile(path.join(runtimeDir, 'app.js'), getEntryModule());

      /**
       * TODO: resolve the user config and merge it with ours...
       *
       * potentially "get" the config if it needs to be shared?
       *
       * What do we do about watch?
       */

      await viteBuildTask(ctx, {
        /**
         * We don't care about js vs jsx here.
         * And that's okay.
         */
        esbuild: {
          loader: 'jsx',
          include: /src\/.*\.jsx?$/,
          exclude: [],
        },
        plugins: [viteReact(), nodeResolve()],
        mode: 'production',
        base: '/',
        build: {
          assetsDir: 'public',
          minify: 'esbuild',
          rollupOptions: {
            input: {
              strapi: path.join(cwd, '.strapi', 'client', 'app.js'),
            },
          },
        },
      });
    } else if (builder === 'webpack') {
      /**
       * TODO: webpack backward compatibility.
       */
    }

    spinner.complete('@strapi/admin: Admin UI build successful');
  } catch (err) {
    spinner.error('@strapi/admin: Admin UI build failed');
    console.error(err);
    process.exit(1);
  }

  // Always remove the .cache and build folders
  // await strapiAdmin.clean({ appDir: srcDir, buildDestDir });

  // return strapiAdmin
  //   .build({
  //     appDir: srcDir,
  //     buildDestDir,
  //     // front end build env is always production for now
  //     env: 'production',
  //     plugins,
  //     options: {
  //       backend: serverUrl,
  //       adminPath: addSlash(adminPath),
  //       telemetryIsDisabled: strapiInstance.telemetry.isDisabled,
  //     },
  //   })
  //   .then(() => {
  //     console.log('Admin UI built successfully');
  //   })
  //   .catch((err) => {
  //     console.error(err);
  //     process.exit(1);
  //   });
};

/**
 * @typedef BuildContextOptions
 * @property {string} cwd
 * @property {string} distDir
 * @property {string} tsconfig
 */

/**
 * @typedef BuildContext
 * @property {string} cwd
 * @property {string} distDir
 * @property {string[]} external
 * @property {object} ts
 * @property {Pick<import('typescript').ParsedCommandLine, 'options'>} ts.config
 * @property {string} ts.configPath
 */

/**
 * @internal
 * @type {(options: BuildContextOptions) => Promise<BuildContext>}
 *
 * @description Create the build context to be used by either build pipeline.
 * @note If this became more generic to build
 * packages we could look at extending the context to expose more things like your export map etc.
 */
const createBuildContext = async ({ cwd, tsconfig: tsconfigPath, distDir }) => {
  const pkg = await loadPkg({ cwd });

  let tsconfig;

  if (tsconfigPath) {
    /**
     * @type {Omit<import('typescript').ParsedCommandLine, 'errors'>}
     */
    const { options } = await tsUtils.resolveConfigOptions(tsconfigPath);

    tsconfig = options;
  }

  /**
   * TODO: pass the target versions to the build pipeline for the admin panel meaning people
   * can support their own versions e.g. something dead if they wanted too?
   */
  // const targetVersions = resolveBrowserslistVersions(
  //   pkg.browserslist || DEFAULT_BROWSERSLIST_QUERY
  // );

  const parsedExternal = [
    ...(pkg.dependencies ? Object.keys(pkg.dependencies) : []),
    ...(pkg.peerDependencies ? Object.keys(pkg.peerDependencies) : []),
  ];

  const ctx = {
    cwd,
    distDir,
    external: parsedExternal,
    ts: {
      config: tsconfig,
      configPath: tsconfigPath,
    },
  };

  return ctx;
};

/**
 * @internal
 * @note could this be moved to somewhere global?
 * @type {(msg: string) => {complete: (msg?: string) => void; error: (msg?: string) => void}}
 */
const createSpinner = (msg) => {
  const startTime = Date.now();

  console.log(msg);

  return {
    complete(msg) {
      console.log(
        `${chalk.green('[success]')}${msg ? ` ${msg}` : ''} ${chalk.gray(
          `${Date.now() - startTime}ms`
        )}`
      );
    },
    error(msg) {
      console.log(
        `${chalk.red(`[error]`)}${msg ? ` ${msg}` : ''} ${chalk.gray(
          `${Date.now() - startTime}ms`
        )}`
      );
    },
  };
};

module.exports = buildAdmin;
